#!/usr/bin/env python3

import os
import argparse
import sys
import textwrap

import lib.fuzzy_match

import application
import show_edit

CONFIG_PATH = "~/.config/mpex/"
CONFIG_PATH = os.path.expanduser(CONFIG_PATH)


def parse_annex_names(app,args):
	""" parse annexes supplied by the user """
	# if nothing is given, return all
	if not args.annex:
		return app.annexes.getAll()
	
	# save
	annex_names = args.annex 
	
	# find all known names
	known_annexes = {repo.annex for repo in app.getHostedRepositories()}
	known_annexes = {annex.name: annex for annex in known_annexes}

	selected_annexes = set()

	for annex_name in annex_names:
		try: 
			# find and add annex
			annex = lib.fuzzy_match.fuzzyMatch(annex_name,known_annexes)
			selected_annexes.add(annex)
		except ValueError as e:
			print("could not parse the annex'%s': %s" % (annex_name,e.args[0]))
			sys.exit()
	
	return selected_annexes

def apply_function(args,f):
	""" apply f to all given annex_names """
	# create application
	app = application.Application(CONFIG_PATH)
	# parse annex names
	selected_annexes = parse_annex_names(app,args)
	
	for repo in sorted(app.getHostedRepositories(),key=lambda r: str((r.annex,r.path))):
		# check if the repo belongs to a selected annex, if yes, then execute f
		if repo.annex in selected_annexes:
			f(repo)
	

#
# initialise repositories
#
def init_init(parsers):
	parser = parsers.add_parser('init', help='create repositories.')
	parser.add_argument('annex', nargs='*', help="Annex names")
	parser.add_argument('--ignorenonempty', action='store_true', default=False,
							help="initialise directories even if they are non empty")
	parser.set_defaults(func=func_init)

def func_init(args):
	def repo_init(repo):
		repo.init(ignorenonempty=args.ignorenonempty)
	apply_function(args,repo_init)
	
#
# reinitialise repositories
#
def init_reinit(parsers):
	parser = parsers.add_parser('reinit', help='reinitialise repositories.')
	parser.add_argument('annex', nargs='*', help="annex names")
	parser.set_defaults(func=func_reinit)

def func_reinit(args):
	def repo_reinit(repo):
		repo.setProperties()
	apply_function(args,repo_reinit)
	
#
# finalise repositories
#
def init_finalise(parsers):
	parser = parsers.add_parser('finalise', help='finalise repositories.')
	parser.add_argument('annex', nargs='*', help="annex names")
	parser.set_defaults(func=func_finalise)

def func_finalise(args):
	def repo_finalise(repo):
		repo.finalise()
	apply_function(args,repo_finalise)
	
#
# synchronise repositories
#
def init_sync(parsers):
	parser = parsers.add_parser('sync', help='synchronise repositories.')
	parser.add_argument('annex', nargs='*', help="annex names")
	parser.set_defaults(func=func_sync)

def func_sync(args):
	def repo_sync(repo):
		repo.sync()
	apply_function(args,repo_sync)
	

#
# copy repositories
#
def init_copy(parsers):
	parser = parsers.add_parser('copy', help='copy repositories.')
	parser.add_argument('annex', nargs='*', help="annex names")
	parser.add_argument('--files', default=None, help="files expression for the local host")
	parser.add_argument('--strict', action="store_true", help="apply strict")
	parser.add_argument('--nostrict', action="store_true", help="apply no strict")
	parser.set_defaults(func=func_copy)

def func_copy(args):
	# get strict flag
	strict = None
	if args.strict:
		strict = True
	if args.nostrict:
		strict = False
	
	def repo_copy(repo):
		repo.copy(files=args.files,strict=strict)
	apply_function(args,repo_copy)

#
# run the given command against the repositories
#
def init_command(parsers):
	epilog  = textwrap.dedent("""\
				Examples:
				   %(prog)s git status
				   %(prog)s -- git annex status --fast
				   %(prog)s cat .git/config
				""")
	parser = parsers.add_parser('command',
									help='run the given command against the repositories.',
									epilog=epilog,
									formatter_class=argparse.RawDescriptionHelpFormatter)
	#parser.add_argument('annex', nargs='*', help="Annex names")
	parser.add_argument('command', nargs='+', help="command to run")
	parser.set_defaults(func=func_command)

def func_command(args):
	# select all annexes
	args.annex = None
	
	def repo_command(repo):
		print("\033[1;37;44m running the command for %s in %s \033[0m" % (repo.annex.name,repo.path))
		# run the command in the directory
		repo.changePath()
		repo.executeCommand(args.command)
		print()
	apply_function(args,repo_command)


#
#
# show data
#
def init_show(parsers):
	parser = parsers.add_parser('show', help='show data.')
	parser.set_defaults(func=func_show)

def func_show(args):
	# create application
	app = application.Application(CONFIG_PATH)
	
	# show app data
	show_edit.show(app)

#
# edit data
#
def init_edit(parsers):
	parser = parsers.add_parser('edit', help='edit data.')
	parser.set_defaults(func=func_edit)

def func_edit(args):
	# create application
	app = application.Application(CONFIG_PATH)

	try:
		# edit app data
		show_edit.edit(app)
	except KeyboardInterrupt:
		print()
		print("received ^C, going down WITHOUT saving")
		return

#
# set host
#
def init_sethost(parsers):
	parser = parsers.add_parser('sethost', help='set the current host.')
	parser.add_argument('host', help="host name")
	parser.set_defaults(func=func_sethost)

def func_sethost(args):
	# create application
	app = application.Application(CONFIG_PATH)

	try:
		host = app.hosts.fuzzyMatch(args.host)
		print("setting host to %s." % host.name)
		app.setCurrentHost(host)
	except Exception as e:
		print("an error has occured: %s" % e.args[0])
	

def runParser():
	# create the top-level parser
	parser = argparse.ArgumentParser(prog='mpex')

	# create sub parsers
	subparsers = parser.add_subparsers()
	init_init(subparsers)
	init_reinit(subparsers)
	init_finalise(subparsers)
	init_sync(subparsers)
	init_copy(subparsers)
	init_command(subparsers)
	init_show(subparsers)
	init_edit(subparsers)
	init_sethost(subparsers)

	# parse arguments and call function
	args = parser.parse_args()
	
	if hasattr(args,"func"):
		# if everything is OK, call the function
		args.func(args)
	else:
		# print a warning
		parser.print_usage()
		print("Error: too few arguments")
	
if __name__ == "__main__":
	runParser()
