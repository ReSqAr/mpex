#!/usr/bin/env python3

import os
import argparse
import sys

import application


CONFIG_PATH = "~/.config/mpex/"
CONFIG_PATH = os.path.expanduser(CONFIG_PATH)


def parse_annex(app,args):
	""" parse annexes supplied by the user """
	# if nothing is given, return None
	if not args.annex:
		return None
	
	# save
	annex_names = args.annex 
	
	# find all known names
	known_annexes = {repo.annex for repo in app.getHostedRepositories()}
	known_annexes = {annex.name for annex in known_annexes}
	known_annexes_lower = {annex_name.lower() for annex_name in known_annexes}
	
	# make sure that all given annexes indeed exist
	for annex_name in annex_names:
		if annex_name.lower() not in known_annexes_lower:
			print("Annex description '%s' is not known." % annex_name)
			print("Known annexes: %s" % ", ".join(sorted(known_annexes)))
			sys.exit()
	
	return annex_names

def apply_function(args,f):
	""" apply f to all given annex_names """
	# create application
	app = application.Application(CONFIG_PATH)
	# parse annex names
	annex_names = parse_annex(app,args)
	# create lower case version
	if annex_names is not None:
		annex_names_lower = {annex_name.lower() for annex_name in annex_names}
	
	for repo in app.getHostedRepositories():
		# if either
		# a) all repositories should be iterated over, or
		# b) the name matches
		# execute f
		if annex_names is None or repo.annex.name.lower() in annex_names_lower:
			f(repo)
	

#
# initialise repositories
#
def init_init(parsers):
	parser = parsers.add_parser('init', help='create repositories.')
	parser.add_argument('annex', nargs='*', help="Annex names")
	parser.add_argument('--ignorenonempty', action='store_true', default=False,
							help="initialise directories even if they are non empty")
	parser.set_defaults(func=func_init)

def func_init(args):
	def repo_init(repo):
		repo.init(ignorenonempty=args.ignorenonempty)
	apply_function(args,repo_init)
	
#
# reinitialise repositories
#
def init_reinit(parsers):
	parser = parsers.add_parser('reinit', help='reinitialise repositories.')
	parser.add_argument('annex', nargs='*', help="annex names")
	parser.set_defaults(func=func_reinit)

def func_reinit(args):
	def repo_reinit(repo):
		repo.setProperties()
	apply_function(args,repo_reinit)
	
#
# finalise repositories
#
def init_finalise(parsers):
	parser = parsers.add_parser('finalise', help='finalise repositories.')
	parser.add_argument('annex', nargs='*', help="annex names")
	parser.set_defaults(func=func_finalise)

def func_finalise(args):
	def repo_finalise(repo):
		repo.finalise()
	apply_function(args,repo_finalise)
	
#
# synchronise repositories
#
def init_sync(parsers):
	parser = parsers.add_parser('sync', help='synchronise repositories.')
	parser.add_argument('annex', nargs='*', help="annex names")
	parser.set_defaults(func=func_sync)

def func_sync(args):
	def repo_sync(repo):
		repo.sync()
	apply_function(args,repo_sync)
	

#
# copy repositories
#
def init_copy(parsers):
	parser = parsers.add_parser('copy', help='copy repositories.')
	parser.add_argument('annex', nargs='*', help="annex names")
	parser.add_argument('--files', default=None, help="files expression for the local host")
	parser.add_argument('--strict', action="store_true", help="apply strict")
	parser.add_argument('--nostrict', action="store_true", help="apply no strict")
	parser.set_defaults(func=func_copy)

def func_copy(args):
	# get strict flag
	strict = None
	if args.strict:
		strict = True
	if args.nostrict:
		strict = False
	
	def repo_copy(repo):
		repo.copy(files=args.files,strict=strict)
	apply_function(args,repo_copy)


#
# show and edit helper functions
#
def print_table(table,sep=2):
	""" prints a table """
	# empty table -> do nothing
	if not table:
		return
	# number of columns, determined by the first row
	# (has to be constant)
	columns = len(table[0])
	# array which holds the length of the individual columns
	column_lengths = columns * [0]
	# iterate over rows
	for row in table:
		# check that it has the correct number of columns
		assert len(row) == columns, "Programming error."
		# update lengths array
		column_lengths = [max(len(row[i]),column_lengths[i]) for i in range(columns)]
	
	# output
	for i,row in enumerate(table):
		for column_length,item in zip(column_lengths,row):
			# print the item left justified
			print(item.ljust(column_length+sep),end='')
		# print a new line
		print()

		# the first line is the header
		if i == 0:
			print("-" * (sum(column_lengths) + (len(column_lengths)-1) * sep))

def create_hosts_table(hosts):
	""" builds a table """
	# we build a table: a 2 dimensional array
	table = []
	# the first line is the header
	table.append(["Host","Associated annexes"])
	
	for host in sorted(hosts,key=lambda h:str(h)):
		# create a row
		row = []
		# first column is the host name
		row.append(host.name)
		# second column are all associated annexes
		repos = host.repositories()
		row.append(", ".join(sorted(repo.annex.name for repo in repos)))
		# append row
		table.append(row)
	
	return table

def create_annexes_table(annexes):
	""" builds a table """
	# we build a table: a 2 dimensional array
	table = []
	# the first line is the header
	table.append(["Annex","Associated hosts"])
	
	for annex in sorted(annexes,key=lambda a:str(a)):
		# create a row
		row = []
		# first column is the annex name
		row.append(annex.name)
		# second column are all associated hosts
		repos = annex.repositories()
		row.append(", ".join(sorted(repo.host.name for repo in repos)))
		# append row
		table.append(row)
	
	return table
		
def create_repositories_table(repositories):
	""" builds a table """
	# we build a table: a 2 dimensional array
	table = []
	# the first line is the header
	table.append(["Host","Annex","Path","Options"])
	
	for repo in sorted(repositories,key=lambda r:str((r.host,r.annex,r.path))):
		# create a row
		row = []
		# first column is the host name
		row.append(repo.host.name)
		# second column is the annex name
		row.append(repo.annex.name)
		# third column is the path
		row.append(repo.path)
		# fourth column are the options
		options = []
		if repo.direct:
			options.append("direct")
		if repo.strict:
			options.append("strict")
		if repo.files:
			options.append("files='%s'" % repo.files)
		if repo.trust != "semitrust":
			options.append("trust: %s" % repo.trust)
		if repo.hasNonTrivialDescription():
			options.append("description: %s" % repo.description)
		row.append(", ".join(options))
		# append row
		table.append(row)

	return table

def create_connections_table(connections):
	""" builds a table """
	# we build a table: a 2 dimensional array
	table = []
	# the first line is the header
	table.append(["Source","Destination","Path","Options"])
	
	for conn in sorted(connections,key=lambda c:str((c.source,c.dest,c.path))):
		# create a row
		row = []
		# first column is the source host name
		row.append(conn.source.name)
		# second column is the destination host name
		row.append(conn.dest.name)
		# third column is the path
		row.append(conn.path)
		# fourth column are the options
		options = []
		if conn.alwaysOn:
			options.append("always on")
		row.append(", ".join(options))
		# append row
		table.append(row)
	return table




#
# show data
#
def init_show(parsers):
	parser = parsers.add_parser('show', help='show data.')
	parser.set_defaults(func=func_show)

def func_show(args):
	# create application
	app = application.Application(CONFIG_PATH)
	
	# print known hosts
	hosts = app.hosts.getAll()
	if not hosts:
		print("There are no registered hosts.")
	else:
		print("There are %d registered hosts:" % len(hosts))
		# create and print table
		table = create_hosts_table(hosts)
		print_table(table)
	print()
	
	# print known annexes
	annexes = app.annexes.getAll()
	if not annexes:
		print("There are no registered annexes.")
	else:
		print("There are %d registered annexes:" % len(annexes))
		# create and print table
		table = create_annexes_table(annexes)
		print_table(table)
	print()
	
	# print known repositories
	repositories = app.repositories.getAll()
	if not repositories:
		print("There are no registered repositories.")
	else:
		print("There are %d registered repositories:" % len(repositories))
		# create and print table
		table = create_repositories_table(repositories)
		print_table(table)
	print()
	
	# print known connections
	connections = app.connections.getAll()
	if not connections:
		print("There are no registered connections.")
	else:
		print("There are %d registered connections:" % len(connections))
		# create and print table
		table = create_connections_table(connections)
		print_table(table)


#
# edit data
#
def init_edit(parsers):
	parser = parsers.add_parser('edit', help='edit data.')
	parser.set_defaults(func=func_edit)

def func_edit(args):
	raise NotImplementedError
	



def runParser():
	# create the top-level parser
	parser = argparse.ArgumentParser(prog='mpex')

	# create sub parsers
	subparsers = parser.add_subparsers(help='There are some subcommands.')
	init_init(subparsers)
	init_reinit(subparsers)
	init_finalise(subparsers)
	init_sync(subparsers)
	init_copy(subparsers)
	init_show(subparsers)
	init_edit(subparsers)

	# parse arguments and call function
	args = parser.parse_args()
	
	if hasattr(args,"func"):
		# if everything is OK, call the function
		args.func(args)
	else:
		# print a warning
		parser.print_usage()
		print("Error: too few arguments")
	
if __name__ == "__main__":
	runParser()
